// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`should be able to set a custom expression addToDictionary helper > for common-cases 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  "some string",
  \`something\`,
  "abc",
  $\`123\${0}another thing\`,
]);
import { foo } from "my-module.js";

// const constant = "some string";
const constant = D[0];

foo({
  // bar: "abc",
  bar: D[2],
  // baz: \`something\${constant}456\`,
  baz: \`\${D[1]}\${constant}456\`,
  // bat: foo\`123\${constant}another thing\`,
  bat: foo(D[3], constant),
});
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for commonjs-require 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'test',
]);
const foo = require('foo-module');
foo(D[0]);
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for conflict 1`] = `
"const B = (v) => console.log(v);
const A = B([
  "test",
]);
// Create conflicting bindings for the default names of the helpers.
const $ = 123;
const D = 456;
console.log(/* (attached comment) */ A[0]);
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for jsx 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  "Escape special characters with the \\"\\\\\\" character.",
  "Text content. With more than one line. And another.",
  "Â entity reference",
  'quotes"inside',
  'with"\\'quotes',
  '--top-offset',
  "some content",
  "something'",
  'error-info',
  'value',
  \`--is-stuck\`,
  \`px\`,
]);
import {
  AnotherComponent,
  ErrorHandler,
  Flex,
  SomeComponent,
  SomethingElse,
  BLOCK,
  classNames,
  isStuck,
  reportError,
  topOffset,
} from 'framework';

export function MyComponent(props) {
  return (
    <SomeComponent attr={D[7]} with={D[3]}>
      <AnotherComponent attr={D[4]} />
      <SomethingElse style={{
        key: D[9],
        anotherKey: props.key2,
      }}
      >{D[1]}</SomethingElse>
      <ErrorHandler
        onError={(info) => {
          reportError({ [D[8]]: info });
        }}
      />
      <Flex
        style={
          {
            [D[5]]: \`\${topOffset}px\`,
          }
        }
        className={classNames(BLOCK, {
          [\`\${BLOCK}\${D[10]}\`]: isStuck,
        })}
      >{D[0]}</Flex>
      <svg
        fill={props.fill}
        content={(() => { return D[6]; })()}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 192 192"
        data={D[2]}
      >
        <g>
          <rect x='84' y='156' width='20' height='20' />
        </g>
        <path
          d="M102,140H86v-20c0-13.5,10.1-24,22.9-24c13.2,0,23-3,28.9-9c5.9-5.9,6.1-12.9,6.1-13l0-0.4l0-0.4c0-0.4,0.8-11.6-7.6-20.8
C128.8,44.2,115.9,40,98,40c-20.9,0-35.6,5.7-43.7,16.9c-6,8.3-6.3,17-6.3,17.1L32,74c0-1.3,0.2-13.3,8.7-25.5
C54.6,28.2,79.5,24,98,24c22.7,0,39.7,6,50.5,17.9c12.2,13.4,11.7,29.6,11.5,32.5c-0.1,2.5-0.9,14-10.8,23.9
c-9.1,9.1-22.6,13.7-40.3,13.7c-4.6,0-6.9,4-6.9,8V140z"
        />
      </svg>
    </SomeComponent>
  );
}
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for reference-size 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  "abcd",
  \`abcdefghi\`,
  "abcde",
  "abc",
  \`abcdefgh\`,
  "xyz0",
  "xyz",
  $\`\`,
  $\`\${0}\${0}\${0}\`,
  "a",
  "ab",
  \`abcde\`,
  \`abcdef\`,
  \`abcdefg\`,
]);
const foo = () => {};

// For short strings, we should use the original string instead of replacing it with a
// dictionary reference.
const short1 = "";
const short2 = "a";
const short3 = "ab";

// Longer strings should be replaced with a dictionary reference.
const long1 = D[3];
const long2 = D[0];
const long3 = D[2];

// Similarly, we should keep short quasis in template literals instead of replacing them
// with a dictionary reference.
const quasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// The dictionary now contains 10 items, which will make the references for any further
// items larger because the size of the index will increase by one character. However,
// we should still be able to use references for all of the examples below, because we
// should be smart enough to reorder the dictionary to make the new items fit.
const twoDigits1 = D[3];
const twoDigits2 = D[0];
const twoDigits3 = D[6];
const twoDigits4 = D[5];

// The same applies to quasis.
const twoDigitsQuasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// We should never replace an empty string, or a sequence of empty quasis, with a
// dictionary reference. (Although for tagged templates, it's a bit trickier to detect
// this case, and so we will continue to generate dictionary entries for them.)
const empty1 = "";
const empty2 = "";
const empty3 = \`\`;
const empty4 = \`\${0}\${1}\${2}\`;
const empty5 = foo(D[7]);
const empty6 = foo(D[8], 0, 1, 2);
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for regular-expressions 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  \`"\`,
]);
import compact from 'lodash/compact';

export const PATTERN = /[:()"\\\\]/g;

const addQuotes = (string, hasQuotes) =>
  hasQuotes ? \`"\${string}"\` : string;
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for string-literals 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  "appendix",
  "gem\`'\\"\\u{6F}",
  "cat\\r\\n\\tdog",
  "observe",
  'quarrel',
  'fizz"\\'"',
  "karat",
  'bowling',
  "egg'\\"'",
  "macrame",
  "nanobot",
  "pacific",
  "hammer",
  "image",
  "jewel",
  "labor",
]);
const foo = () => {};

// Trivial string literals.
const trivial1 = "";
const trivial2 = '';
const trivial3 = D[0];
const trivial4 = D[7];

// Escape sequences.
const escape1 = D[2];
const escape2 = D[8];
const escape3 = D[5];
const escape4 = D[1];

// String literals used in expressions.
const expression1 = D[12].toLowerCase();
const expression2 = foo[D[13]];
const expression3 = foo(D[14]);
const expression4 = D[6][1];

// String literals used in function declarations.
const func1 = (_a = D[15]) => {};

// String literals used in object literals.
const object1 = { [D[9]]: 1 };
const object2 = { [D[10]]: 2 };
const object3 = { [D[3]](_a){} };

// String literals used in array literals.
const array1 = [D[11]];
const array2 = [...D[4]];

// Reuse of string literals we've already seen.
const reuse1 = D[0];
const reuse2 = D[6][1];
const reuse3 = { [D[3]](_a){} };
const reuse4 = [...D[4]];
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for switch-statements 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'francis',
  'result',
  'emmett',
  "arnold",
  'betty',
  $\`danielle\`,
  \`charles\`,
]);
const tag = () => D[1];

export const foo = (value) => {
  const emmett = D[2];

  switch (value) {
    case D[3]:
      return 1;

    case D[4]:
      return 2;

    case \`charles\`:
      return 3;

    case tag(D[5]):
      return 4;

    case emmett:
      return 5;

    case D[0]:
      return 6;

    default:
      return 7;
  }
};
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for tagged-templates-only 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  $\`bar\${0}\`,
]);
function foo() { }
console.log(foo(D[0], 1000))
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for templates 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  \`\\\`'"\\u{6F}\`,
  \`abc\\r\\n\\t123\`,
  \`gallingly\`,
  \`hairbrush\`,
  \`idealists\`,
  \`absolute\`,
  \`backdrops\`,
  \`cacophony\`,
  \`dachshund\`,
  \`eagerness\`,
  \`fabricate\`,
  \`newlyweds\`,
  \`orthodoxy\`,
  \`paralyzed\`,
  \`quadrants\`,
  \`reflexive\`,
  \`waferlike\`,
  \`yardstick\`,
  $\`superior\${0}vertical\`,
  $\`triangle\${0}umbrella\`,
  $\`\`,
  $\`judgment\`,
  $\`keyboard\${0}laughter\${0}material\`,
  $\`abstract\`,
  $\`doubtful\${0}endeavor\`,
  $\`bacteria\${0}contrast\`,
]);
const foo = () => {};
const bar = 1;

// Trivial template expressions.
const trivial1 = \`\`;
const trivial2 = \`\${D[5]}\`;
const trivial3 = \`\${D[6]}\${bar}\`;
const trivial4 = \`\${bar}\${D[7]}\`;
const trivial5 = \`\${D[8]}\${bar}\`;
const trivial6 = \`\${D[9]}\${bar}\${D[10]}\`;
const trivial7 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;

// Escape sequences.
const escape1 = \`\${D[1]}\`;
const escape2 = \`\${D[0]}\`;

// Tagged template expressions.
const tagged1 = foo(D[20]);
const tagged2 = foo(D[21]);
const tagged3 = foo(D[22], bar, bar);

// Nested template expressions.
const nested1 = \`\${D[11]}\${\`\${D[12]}\${\`\${D[13]}\`}\${D[14]}\`}\${D[15]}\`;
const nested2 = foo(D[18], foo(D[19], bar));
const nested3 = \`\${D[16]}\${bar}\${D[17]}\${foo(D[23])}\`;

// Using the results of template expressions as a tag.
const resulttag1 = foo(D[25], bar)(D[24], bar);

// Reuse of quasis and template expressions that we've already seen.
const reuse1 = \`\${D[5]}\`;
const reuse2 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;
const reuse3 = \`\${D[0]}\`;
const reuse4 = foo(D[18], foo(D[19], bar));
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for ternary-expressions 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'katherine',
  "charles",
  'ophelia',
  'richard',
  'result',
  "arnold",
  'george',
  'marcia',
  'nathan',
  "betty",
  'harry',
  'irina',
  'peter',
  'quinn',
  'jack',
  $\`danielle\`,
  $\`emmett\`,
  $\`francine\`,
]);
const tag = () => D[4];

export const arnold = D[5] ? D[9] : D[1];
export const danielle = tag(D[15]) ? tag(D[16]) : tag(D[17]);
export const george = D[6] ? (D[10], D[11]) : (D[14], D[0]);
export const leopold = { [D[7]]: D[8] } ? { [D[2]]: D[12] } : { 'quinn': D[3] };
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for trivial 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  "test",
]);
console.log(/* (attached comment) */ D[0]);

"
`;

exports[`should be able to set a custom expression addToDictionary helper > for typescript-enums 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'Number Three',
  'Number One',
  'Letter A',
  "Letter B",
  "Number Two",
  'Number Two',
  'Letter C',
  'Alpha',
  "Beta",
  \`Letter C\`,
  \`Gamma\`,
]);
enum GreekLetters {
  Alpha = 'Alpha',
  Beta = "Beta",
  Gamma = \`Gamma\`,
}

enum RomanLetters {
  'Letter A' = 'Letter A',
  "Letter B" = "Letter B",
  'Letter C' = \`Letter C\`,
}

const enum ArabicNumbers {
  'Number One' = 'Number One',
  "Number Two" = 'Number Two',
  'Number Three' = 'Number Three',
}
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for typescript-inheritance 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'SpecificNode',
  'pattern',
]);
import { Variant } from './variant';

export class SpecificNode
    extends Variant(D[0])<[string, {}]>
{
    pattern(): string {
        return { escaped: D[1] };
    }
}
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for typescript-namespaces 1`] = `
"const $ = (v) => console.log(v);
const D = $([
  'betelgeuse',
  'cassiopeia',
  'andromeda',
]);
declare module SomeModule {
  const variable = D[2];
}

declare module "SomeModule" {
  const variable = D[0];
}

declare namespace SomeNamespace {
  const variable = D[1];
}
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for unwanted 1`] = `
"// No strings in this file should appear in the dictionary.
"use strict";
"use server";
"use client";
import "unwanted1.js";
import foo from "unwanted2.js";
import { foo } from "unwanted3.js";
import * as foo from "unwanted4.js";
import { foo as bar1 } from "unwanted5.js";
import { default as bar2 } from "unwanted6.js";
import { "unwanted7" as bar3 } from "unwanted8.js";
export { bar1 };
export { bar1 as bar2 };
export { bar1 as "unwanted9" };
export * from "unwanted10.js";
export * as foo from "unwanted11.js";
export { bar } from "unwanted12.js";
export { default } from "unwanted13.js";
export { default as bar } from "unwanted14.js";
export { foo as "unwanted15" } from "unwanted16.js";
const bar4 = require("unwanted17.js");
const bar5 = import("unwanted18.js");
function doSomething() {
  "use strict";
  return 0;
}
"
`;

exports[`should be able to set a custom expression addToDictionary helper > for unwanted-typescript 1`] = `
"// No strings in this file should appear in the dictionary.
let foo: 'unwanted_var_type_1' | "unwanted_var_type_2";

function bar(
  x: "unwanted_arg_type_1",
  y: 'unwanted_arg_type_2'
): 'unwanted_return_value_type_3' | undefined {
  return undefined;
}

type ObjectType = {
  'unwanted_object_key_type_1': 'unwanted_object_value_type_1'
};

interface InterfaceType {
  'unwanted_interface_key_type_1': 'unwanted_interface_value_type_1'
};

declare let baz: 'unwanted_declared_var_type_1';
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for common-cases 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  "some string",
  \`something\`,
  "abc",
  $\`123\${0}another thing\`,
]);
import { foo } from "my-module.js";

// const constant = "some string";
const constant = D[0];

foo({
  // bar: "abc",
  bar: D[2],
  // baz: \`something\${constant}456\`,
  baz: \`\${D[1]}\${constant}456\`,
  // bat: foo\`123\${constant}another thing\`,
  bat: foo(D[3], constant),
});
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for commonjs-require 1`] = `
"const { addToDictionary: $ } = require('@custom/helpers.cjs');
const D = $([
  'test',
]);
const foo = require('foo-module');
foo(D[0]);
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for conflict 1`] = `
"import { addToDictionary as B } from '@custom/helpers.mjs';
const A = B([
  "test",
]);
// Create conflicting bindings for the default names of the helpers.
const $ = 123;
const D = 456;
console.log(/* (attached comment) */ A[0]);
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for jsx 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  "Escape special characters with the \\"\\\\\\" character.",
  "Text content. With more than one line. And another.",
  "Â entity reference",
  'quotes"inside',
  'with"\\'quotes',
  '--top-offset',
  "some content",
  "something'",
  'error-info',
  'value',
  \`--is-stuck\`,
  \`px\`,
]);
import {
  AnotherComponent,
  ErrorHandler,
  Flex,
  SomeComponent,
  SomethingElse,
  BLOCK,
  classNames,
  isStuck,
  reportError,
  topOffset,
} from 'framework';

export function MyComponent(props) {
  return (
    <SomeComponent attr={D[7]} with={D[3]}>
      <AnotherComponent attr={D[4]} />
      <SomethingElse style={{
        key: D[9],
        anotherKey: props.key2,
      }}
      >{D[1]}</SomethingElse>
      <ErrorHandler
        onError={(info) => {
          reportError({ [D[8]]: info });
        }}
      />
      <Flex
        style={
          {
            [D[5]]: \`\${topOffset}px\`,
          }
        }
        className={classNames(BLOCK, {
          [\`\${BLOCK}\${D[10]}\`]: isStuck,
        })}
      >{D[0]}</Flex>
      <svg
        fill={props.fill}
        content={(() => { return D[6]; })()}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 192 192"
        data={D[2]}
      >
        <g>
          <rect x='84' y='156' width='20' height='20' />
        </g>
        <path
          d="M102,140H86v-20c0-13.5,10.1-24,22.9-24c13.2,0,23-3,28.9-9c5.9-5.9,6.1-12.9,6.1-13l0-0.4l0-0.4c0-0.4,0.8-11.6-7.6-20.8
C128.8,44.2,115.9,40,98,40c-20.9,0-35.6,5.7-43.7,16.9c-6,8.3-6.3,17-6.3,17.1L32,74c0-1.3,0.2-13.3,8.7-25.5
C54.6,28.2,79.5,24,98,24c22.7,0,39.7,6,50.5,17.9c12.2,13.4,11.7,29.6,11.5,32.5c-0.1,2.5-0.9,14-10.8,23.9
c-9.1,9.1-22.6,13.7-40.3,13.7c-4.6,0-6.9,4-6.9,8V140z"
        />
      </svg>
    </SomeComponent>
  );
}
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for reference-size 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  "abcd",
  \`abcdefghi\`,
  "abcde",
  "abc",
  \`abcdefgh\`,
  "xyz0",
  "xyz",
  $\`\`,
  $\`\${0}\${0}\${0}\`,
  "a",
  "ab",
  \`abcde\`,
  \`abcdef\`,
  \`abcdefg\`,
]);
const foo = () => {};

// For short strings, we should use the original string instead of replacing it with a
// dictionary reference.
const short1 = "";
const short2 = "a";
const short3 = "ab";

// Longer strings should be replaced with a dictionary reference.
const long1 = D[3];
const long2 = D[0];
const long3 = D[2];

// Similarly, we should keep short quasis in template literals instead of replacing them
// with a dictionary reference.
const quasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// The dictionary now contains 10 items, which will make the references for any further
// items larger because the size of the index will increase by one character. However,
// we should still be able to use references for all of the examples below, because we
// should be smart enough to reorder the dictionary to make the new items fit.
const twoDigits1 = D[3];
const twoDigits2 = D[0];
const twoDigits3 = D[6];
const twoDigits4 = D[5];

// The same applies to quasis.
const twoDigitsQuasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// We should never replace an empty string, or a sequence of empty quasis, with a
// dictionary reference. (Although for tagged templates, it's a bit trickier to detect
// this case, and so we will continue to generate dictionary entries for them.)
const empty1 = "";
const empty2 = "";
const empty3 = \`\`;
const empty4 = \`\${0}\${1}\${2}\`;
const empty5 = foo(D[7]);
const empty6 = foo(D[8], 0, 1, 2);
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for regular-expressions 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  \`"\`,
]);
import compact from 'lodash/compact';

export const PATTERN = /[:()"\\\\]/g;

const addQuotes = (string, hasQuotes) =>
  hasQuotes ? \`"\${string}"\` : string;
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for string-literals 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  "appendix",
  "gem\`'\\"\\u{6F}",
  "cat\\r\\n\\tdog",
  "observe",
  'quarrel',
  'fizz"\\'"',
  "karat",
  'bowling',
  "egg'\\"'",
  "macrame",
  "nanobot",
  "pacific",
  "hammer",
  "image",
  "jewel",
  "labor",
]);
const foo = () => {};

// Trivial string literals.
const trivial1 = "";
const trivial2 = '';
const trivial3 = D[0];
const trivial4 = D[7];

// Escape sequences.
const escape1 = D[2];
const escape2 = D[8];
const escape3 = D[5];
const escape4 = D[1];

// String literals used in expressions.
const expression1 = D[12].toLowerCase();
const expression2 = foo[D[13]];
const expression3 = foo(D[14]);
const expression4 = D[6][1];

// String literals used in function declarations.
const func1 = (_a = D[15]) => {};

// String literals used in object literals.
const object1 = { [D[9]]: 1 };
const object2 = { [D[10]]: 2 };
const object3 = { [D[3]](_a){} };

// String literals used in array literals.
const array1 = [D[11]];
const array2 = [...D[4]];

// Reuse of string literals we've already seen.
const reuse1 = D[0];
const reuse2 = D[6][1];
const reuse3 = { [D[3]](_a){} };
const reuse4 = [...D[4]];
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for switch-statements 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  'francis',
  'result',
  'emmett',
  "arnold",
  'betty',
  $\`danielle\`,
  \`charles\`,
]);
const tag = () => D[1];

export const foo = (value) => {
  const emmett = D[2];

  switch (value) {
    case D[3]:
      return 1;

    case D[4]:
      return 2;

    case \`charles\`:
      return 3;

    case tag(D[5]):
      return 4;

    case emmett:
      return 5;

    case D[0]:
      return 6;

    default:
      return 7;
  }
};
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for tagged-templates-only 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  $\`bar\${0}\`,
]);
function foo() { }
console.log(foo(D[0], 1000))
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for templates 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  \`\\\`'"\\u{6F}\`,
  \`abc\\r\\n\\t123\`,
  \`gallingly\`,
  \`hairbrush\`,
  \`idealists\`,
  \`absolute\`,
  \`backdrops\`,
  \`cacophony\`,
  \`dachshund\`,
  \`eagerness\`,
  \`fabricate\`,
  \`newlyweds\`,
  \`orthodoxy\`,
  \`paralyzed\`,
  \`quadrants\`,
  \`reflexive\`,
  \`waferlike\`,
  \`yardstick\`,
  $\`superior\${0}vertical\`,
  $\`triangle\${0}umbrella\`,
  $\`\`,
  $\`judgment\`,
  $\`keyboard\${0}laughter\${0}material\`,
  $\`abstract\`,
  $\`doubtful\${0}endeavor\`,
  $\`bacteria\${0}contrast\`,
]);
const foo = () => {};
const bar = 1;

// Trivial template expressions.
const trivial1 = \`\`;
const trivial2 = \`\${D[5]}\`;
const trivial3 = \`\${D[6]}\${bar}\`;
const trivial4 = \`\${bar}\${D[7]}\`;
const trivial5 = \`\${D[8]}\${bar}\`;
const trivial6 = \`\${D[9]}\${bar}\${D[10]}\`;
const trivial7 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;

// Escape sequences.
const escape1 = \`\${D[1]}\`;
const escape2 = \`\${D[0]}\`;

// Tagged template expressions.
const tagged1 = foo(D[20]);
const tagged2 = foo(D[21]);
const tagged3 = foo(D[22], bar, bar);

// Nested template expressions.
const nested1 = \`\${D[11]}\${\`\${D[12]}\${\`\${D[13]}\`}\${D[14]}\`}\${D[15]}\`;
const nested2 = foo(D[18], foo(D[19], bar));
const nested3 = \`\${D[16]}\${bar}\${D[17]}\${foo(D[23])}\`;

// Using the results of template expressions as a tag.
const resulttag1 = foo(D[25], bar)(D[24], bar);

// Reuse of quasis and template expressions that we've already seen.
const reuse1 = \`\${D[5]}\`;
const reuse2 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;
const reuse3 = \`\${D[0]}\`;
const reuse4 = foo(D[18], foo(D[19], bar));
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for ternary-expressions 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  'katherine',
  "charles",
  'ophelia',
  'richard',
  'result',
  "arnold",
  'george',
  'marcia',
  'nathan',
  "betty",
  'harry',
  'irina',
  'peter',
  'quinn',
  'jack',
  $\`danielle\`,
  $\`emmett\`,
  $\`francine\`,
]);
const tag = () => D[4];

export const arnold = D[5] ? D[9] : D[1];
export const danielle = tag(D[15]) ? tag(D[16]) : tag(D[17]);
export const george = D[6] ? (D[10], D[11]) : (D[14], D[0]);
export const leopold = { [D[7]]: D[8] } ? { [D[2]]: D[12] } : { 'quinn': D[3] };
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for trivial 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  "test",
]);
console.log(/* (attached comment) */ D[0]);

"
`;

exports[`should be able to set a custom imported addToDictionary helper > for typescript-enums 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  'Number Three',
  'Number One',
  'Letter A',
  "Letter B",
  "Number Two",
  'Number Two',
  'Letter C',
  'Alpha',
  "Beta",
  \`Letter C\`,
  \`Gamma\`,
]);
enum GreekLetters {
  Alpha = 'Alpha',
  Beta = "Beta",
  Gamma = \`Gamma\`,
}

enum RomanLetters {
  'Letter A' = 'Letter A',
  "Letter B" = "Letter B",
  'Letter C' = \`Letter C\`,
}

const enum ArabicNumbers {
  'Number One' = 'Number One',
  "Number Two" = 'Number Two',
  'Number Three' = 'Number Three',
}
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for typescript-inheritance 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  'SpecificNode',
  'pattern',
]);
import { Variant } from './variant';

export class SpecificNode
    extends Variant(D[0])<[string, {}]>
{
    pattern(): string {
        return { escaped: D[1] };
    }
}
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for typescript-namespaces 1`] = `
"import { addToDictionary as $ } from '@custom/helpers.mjs';
const D = $([
  'betelgeuse',
  'cassiopeia',
  'andromeda',
]);
declare module SomeModule {
  const variable = D[2];
}

declare module "SomeModule" {
  const variable = D[0];
}

declare namespace SomeNamespace {
  const variable = D[1];
}
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for unwanted 1`] = `
"// No strings in this file should appear in the dictionary.
"use strict";
"use server";
"use client";
import "unwanted1.js";
import foo from "unwanted2.js";
import { foo } from "unwanted3.js";
import * as foo from "unwanted4.js";
import { foo as bar1 } from "unwanted5.js";
import { default as bar2 } from "unwanted6.js";
import { "unwanted7" as bar3 } from "unwanted8.js";
export { bar1 };
export { bar1 as bar2 };
export { bar1 as "unwanted9" };
export * from "unwanted10.js";
export * as foo from "unwanted11.js";
export { bar } from "unwanted12.js";
export { default } from "unwanted13.js";
export { default as bar } from "unwanted14.js";
export { foo as "unwanted15" } from "unwanted16.js";
const bar4 = require("unwanted17.js");
const bar5 = import("unwanted18.js");
function doSomething() {
  "use strict";
  return 0;
}
"
`;

exports[`should be able to set a custom imported addToDictionary helper > for unwanted-typescript 1`] = `
"// No strings in this file should appear in the dictionary.
let foo: 'unwanted_var_type_1' | "unwanted_var_type_2";

function bar(
  x: "unwanted_arg_type_1",
  y: 'unwanted_arg_type_2'
): 'unwanted_return_value_type_3' | undefined {
  return undefined;
}

type ObjectType = {
  'unwanted_object_key_type_1': 'unwanted_object_value_type_1'
};

interface InterfaceType {
  'unwanted_interface_key_type_1': 'unwanted_interface_value_type_1'
};

declare let baz: 'unwanted_declared_var_type_1';
"
`;

exports[`the CJS version should transform code correctly > for common-cases 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "some string",
  \`something\`,
  "abc",
  $\`123\${0}another thing\`,
]);
import { foo } from "my-module.js";

// const constant = "some string";
const constant = D[0];

foo({
  // bar: "abc",
  bar: D[2],
  // baz: \`something\${constant}456\`,
  baz: \`\${D[1]}\${constant}456\`,
  // bat: foo\`123\${constant}another thing\`,
  bat: foo(D[3], constant),
});
"
`;

exports[`the CJS version should transform code correctly > for commonjs-require 1`] = `
"const { $ } = require(' datadog:privacy-helpers.cjs');
const D = $([
  'test',
]);
const foo = require('foo-module');
foo(D[0]);
"
`;

exports[`the CJS version should transform code correctly > for conflict 1`] = `
"import { $ as B } from ' datadog:privacy-helpers.mjs';
const A = B([
  "test",
]);
// Create conflicting bindings for the default names of the helpers.
const $ = 123;
const D = 456;
console.log(/* (attached comment) */ A[0]);
"
`;

exports[`the CJS version should transform code correctly > for jsx 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "Escape special characters with the \\"\\\\\\" character.",
  "Text content. With more than one line. And another.",
  "Â entity reference",
  'quotes"inside',
  'with"\\'quotes',
  '--top-offset',
  "some content",
  "something'",
  'error-info',
  'value',
  \`--is-stuck\`,
  \`px\`,
]);
import {
  AnotherComponent,
  ErrorHandler,
  Flex,
  SomeComponent,
  SomethingElse,
  BLOCK,
  classNames,
  isStuck,
  reportError,
  topOffset,
} from 'framework';

export function MyComponent(props) {
  return (
    <SomeComponent attr={D[7]} with={D[3]}>
      <AnotherComponent attr={D[4]} />
      <SomethingElse style={{
        key: D[9],
        anotherKey: props.key2,
      }}
      >{D[1]}</SomethingElse>
      <ErrorHandler
        onError={(info) => {
          reportError({ [D[8]]: info });
        }}
      />
      <Flex
        style={
          {
            [D[5]]: \`\${topOffset}px\`,
          }
        }
        className={classNames(BLOCK, {
          [\`\${BLOCK}\${D[10]}\`]: isStuck,
        })}
      >{D[0]}</Flex>
      <svg
        fill={props.fill}
        content={(() => { return D[6]; })()}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 192 192"
        data={D[2]}
      >
        <g>
          <rect x='84' y='156' width='20' height='20' />
        </g>
        <path
          d="M102,140H86v-20c0-13.5,10.1-24,22.9-24c13.2,0,23-3,28.9-9c5.9-5.9,6.1-12.9,6.1-13l0-0.4l0-0.4c0-0.4,0.8-11.6-7.6-20.8
C128.8,44.2,115.9,40,98,40c-20.9,0-35.6,5.7-43.7,16.9c-6,8.3-6.3,17-6.3,17.1L32,74c0-1.3,0.2-13.3,8.7-25.5
C54.6,28.2,79.5,24,98,24c22.7,0,39.7,6,50.5,17.9c12.2,13.4,11.7,29.6,11.5,32.5c-0.1,2.5-0.9,14-10.8,23.9
c-9.1,9.1-22.6,13.7-40.3,13.7c-4.6,0-6.9,4-6.9,8V140z"
        />
      </svg>
    </SomeComponent>
  );
}
"
`;

exports[`the CJS version should transform code correctly > for reference-size 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "abcd",
  \`abcdefghi\`,
  "abcde",
  "abc",
  \`abcdefgh\`,
  "xyz0",
  "xyz",
  $\`\`,
  $\`\${0}\${0}\${0}\`,
  "a",
  "ab",
  \`abcde\`,
  \`abcdef\`,
  \`abcdefg\`,
]);
const foo = () => {};

// For short strings, we should use the original string instead of replacing it with a
// dictionary reference.
const short1 = "";
const short2 = "a";
const short3 = "ab";

// Longer strings should be replaced with a dictionary reference.
const long1 = D[3];
const long2 = D[0];
const long3 = D[2];

// Similarly, we should keep short quasis in template literals instead of replacing them
// with a dictionary reference.
const quasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// The dictionary now contains 10 items, which will make the references for any further
// items larger because the size of the index will increase by one character. However,
// we should still be able to use references for all of the examples below, because we
// should be smart enough to reorder the dictionary to make the new items fit.
const twoDigits1 = D[3];
const twoDigits2 = D[0];
const twoDigits3 = D[6];
const twoDigits4 = D[5];

// The same applies to quasis.
const twoDigitsQuasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// We should never replace an empty string, or a sequence of empty quasis, with a
// dictionary reference. (Although for tagged templates, it's a bit trickier to detect
// this case, and so we will continue to generate dictionary entries for them.)
const empty1 = "";
const empty2 = "";
const empty3 = \`\`;
const empty4 = \`\${0}\${1}\${2}\`;
const empty5 = foo(D[7]);
const empty6 = foo(D[8], 0, 1, 2);
"
`;

exports[`the CJS version should transform code correctly > for regular-expressions 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  \`"\`,
]);
import compact from 'lodash/compact';

export const PATTERN = /[:()"\\\\]/g;

const addQuotes = (string, hasQuotes) =>
  hasQuotes ? \`"\${string}"\` : string;
"
`;

exports[`the CJS version should transform code correctly > for string-literals 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "appendix",
  "gem\`'\\"\\u{6F}",
  "cat\\r\\n\\tdog",
  "observe",
  'quarrel',
  'fizz"\\'"',
  "karat",
  'bowling',
  "egg'\\"'",
  "macrame",
  "nanobot",
  "pacific",
  "hammer",
  "image",
  "jewel",
  "labor",
]);
const foo = () => {};

// Trivial string literals.
const trivial1 = "";
const trivial2 = '';
const trivial3 = D[0];
const trivial4 = D[7];

// Escape sequences.
const escape1 = D[2];
const escape2 = D[8];
const escape3 = D[5];
const escape4 = D[1];

// String literals used in expressions.
const expression1 = D[12].toLowerCase();
const expression2 = foo[D[13]];
const expression3 = foo(D[14]);
const expression4 = D[6][1];

// String literals used in function declarations.
const func1 = (_a = D[15]) => {};

// String literals used in object literals.
const object1 = { [D[9]]: 1 };
const object2 = { [D[10]]: 2 };
const object3 = { [D[3]](_a){} };

// String literals used in array literals.
const array1 = [D[11]];
const array2 = [...D[4]];

// Reuse of string literals we've already seen.
const reuse1 = D[0];
const reuse2 = D[6][1];
const reuse3 = { [D[3]](_a){} };
const reuse4 = [...D[4]];
"
`;

exports[`the CJS version should transform code correctly > for switch-statements 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'francis',
  'result',
  'emmett',
  "arnold",
  'betty',
  $\`danielle\`,
  \`charles\`,
]);
const tag = () => D[1];

export const foo = (value) => {
  const emmett = D[2];

  switch (value) {
    case D[3]:
      return 1;

    case D[4]:
      return 2;

    case \`charles\`:
      return 3;

    case tag(D[5]):
      return 4;

    case emmett:
      return 5;

    case D[0]:
      return 6;

    default:
      return 7;
  }
};
"
`;

exports[`the CJS version should transform code correctly > for tagged-templates-only 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  $\`bar\${0}\`,
]);
function foo() { }
console.log(foo(D[0], 1000))
"
`;

exports[`the CJS version should transform code correctly > for templates 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  \`\\\`'"\\u{6F}\`,
  \`abc\\r\\n\\t123\`,
  \`gallingly\`,
  \`hairbrush\`,
  \`idealists\`,
  \`absolute\`,
  \`backdrops\`,
  \`cacophony\`,
  \`dachshund\`,
  \`eagerness\`,
  \`fabricate\`,
  \`newlyweds\`,
  \`orthodoxy\`,
  \`paralyzed\`,
  \`quadrants\`,
  \`reflexive\`,
  \`waferlike\`,
  \`yardstick\`,
  $\`superior\${0}vertical\`,
  $\`triangle\${0}umbrella\`,
  $\`\`,
  $\`judgment\`,
  $\`keyboard\${0}laughter\${0}material\`,
  $\`abstract\`,
  $\`doubtful\${0}endeavor\`,
  $\`bacteria\${0}contrast\`,
]);
const foo = () => {};
const bar = 1;

// Trivial template expressions.
const trivial1 = \`\`;
const trivial2 = \`\${D[5]}\`;
const trivial3 = \`\${D[6]}\${bar}\`;
const trivial4 = \`\${bar}\${D[7]}\`;
const trivial5 = \`\${D[8]}\${bar}\`;
const trivial6 = \`\${D[9]}\${bar}\${D[10]}\`;
const trivial7 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;

// Escape sequences.
const escape1 = \`\${D[1]}\`;
const escape2 = \`\${D[0]}\`;

// Tagged template expressions.
const tagged1 = foo(D[20]);
const tagged2 = foo(D[21]);
const tagged3 = foo(D[22], bar, bar);

// Nested template expressions.
const nested1 = \`\${D[11]}\${\`\${D[12]}\${\`\${D[13]}\`}\${D[14]}\`}\${D[15]}\`;
const nested2 = foo(D[18], foo(D[19], bar));
const nested3 = \`\${D[16]}\${bar}\${D[17]}\${foo(D[23])}\`;

// Using the results of template expressions as a tag.
const resulttag1 = foo(D[25], bar)(D[24], bar);

// Reuse of quasis and template expressions that we've already seen.
const reuse1 = \`\${D[5]}\`;
const reuse2 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;
const reuse3 = \`\${D[0]}\`;
const reuse4 = foo(D[18], foo(D[19], bar));
"
`;

exports[`the CJS version should transform code correctly > for ternary-expressions 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'katherine',
  "charles",
  'ophelia',
  'richard',
  'result',
  "arnold",
  'george',
  'marcia',
  'nathan',
  "betty",
  'harry',
  'irina',
  'peter',
  'quinn',
  'jack',
  $\`danielle\`,
  $\`emmett\`,
  $\`francine\`,
]);
const tag = () => D[4];

export const arnold = D[5] ? D[9] : D[1];
export const danielle = tag(D[15]) ? tag(D[16]) : tag(D[17]);
export const george = D[6] ? (D[10], D[11]) : (D[14], D[0]);
export const leopold = { [D[7]]: D[8] } ? { [D[2]]: D[12] } : { 'quinn': D[3] };
"
`;

exports[`the CJS version should transform code correctly > for trivial 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "test",
]);
console.log(/* (attached comment) */ D[0]);

"
`;

exports[`the CJS version should transform code correctly > for typescript-enums 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'Number Three',
  'Number One',
  'Letter A',
  "Letter B",
  "Number Two",
  'Number Two',
  'Letter C',
  'Alpha',
  "Beta",
  \`Letter C\`,
  \`Gamma\`,
]);
enum GreekLetters {
  Alpha = 'Alpha',
  Beta = "Beta",
  Gamma = \`Gamma\`,
}

enum RomanLetters {
  'Letter A' = 'Letter A',
  "Letter B" = "Letter B",
  'Letter C' = \`Letter C\`,
}

const enum ArabicNumbers {
  'Number One' = 'Number One',
  "Number Two" = 'Number Two',
  'Number Three' = 'Number Three',
}
"
`;

exports[`the CJS version should transform code correctly > for typescript-inheritance 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'SpecificNode',
  'pattern',
]);
import { Variant } from './variant';

export class SpecificNode
    extends Variant(D[0])<[string, {}]>
{
    pattern(): string {
        return { escaped: D[1] };
    }
}
"
`;

exports[`the CJS version should transform code correctly > for typescript-namespaces 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'betelgeuse',
  'cassiopeia',
  'andromeda',
]);
declare module SomeModule {
  const variable = D[2];
}

declare module "SomeModule" {
  const variable = D[0];
}

declare namespace SomeNamespace {
  const variable = D[1];
}
"
`;

exports[`the CJS version should transform code correctly > for unwanted 1`] = `
"// No strings in this file should appear in the dictionary.
"use strict";
"use server";
"use client";
import "unwanted1.js";
import foo from "unwanted2.js";
import { foo } from "unwanted3.js";
import * as foo from "unwanted4.js";
import { foo as bar1 } from "unwanted5.js";
import { default as bar2 } from "unwanted6.js";
import { "unwanted7" as bar3 } from "unwanted8.js";
export { bar1 };
export { bar1 as bar2 };
export { bar1 as "unwanted9" };
export * from "unwanted10.js";
export * as foo from "unwanted11.js";
export { bar } from "unwanted12.js";
export { default } from "unwanted13.js";
export { default as bar } from "unwanted14.js";
export { foo as "unwanted15" } from "unwanted16.js";
const bar4 = require("unwanted17.js");
const bar5 = import("unwanted18.js");
function doSomething() {
  "use strict";
  return 0;
}
"
`;

exports[`the CJS version should transform code correctly > for unwanted-typescript 1`] = `
"// No strings in this file should appear in the dictionary.
let foo: 'unwanted_var_type_1' | "unwanted_var_type_2";

function bar(
  x: "unwanted_arg_type_1",
  y: 'unwanted_arg_type_2'
): 'unwanted_return_value_type_3' | undefined {
  return undefined;
}

type ObjectType = {
  'unwanted_object_key_type_1': 'unwanted_object_value_type_1'
};

interface InterfaceType {
  'unwanted_interface_key_type_1': 'unwanted_interface_value_type_1'
};

declare let baz: 'unwanted_declared_var_type_1';
"
`;

exports[`the ESM version should transform code correctly > for common-cases 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "some string",
  \`something\`,
  "abc",
  $\`123\${0}another thing\`,
]);
import { foo } from "my-module.js";

// const constant = "some string";
const constant = D[0];

foo({
  // bar: "abc",
  bar: D[2],
  // baz: \`something\${constant}456\`,
  baz: \`\${D[1]}\${constant}456\`,
  // bat: foo\`123\${constant}another thing\`,
  bat: foo(D[3], constant),
});
"
`;

exports[`the ESM version should transform code correctly > for commonjs-require 1`] = `
"const { $ } = require(' datadog:privacy-helpers.cjs');
const D = $([
  'test',
]);
const foo = require('foo-module');
foo(D[0]);
"
`;

exports[`the ESM version should transform code correctly > for conflict 1`] = `
"import { $ as B } from ' datadog:privacy-helpers.mjs';
const A = B([
  "test",
]);
// Create conflicting bindings for the default names of the helpers.
const $ = 123;
const D = 456;
console.log(/* (attached comment) */ A[0]);
"
`;

exports[`the ESM version should transform code correctly > for jsx 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "Escape special characters with the \\"\\\\\\" character.",
  "Text content. With more than one line. And another.",
  "Â entity reference",
  'quotes"inside',
  'with"\\'quotes',
  '--top-offset',
  "some content",
  "something'",
  'error-info',
  'value',
  \`--is-stuck\`,
  \`px\`,
]);
import {
  AnotherComponent,
  ErrorHandler,
  Flex,
  SomeComponent,
  SomethingElse,
  BLOCK,
  classNames,
  isStuck,
  reportError,
  topOffset,
} from 'framework';

export function MyComponent(props) {
  return (
    <SomeComponent attr={D[7]} with={D[3]}>
      <AnotherComponent attr={D[4]} />
      <SomethingElse style={{
        key: D[9],
        anotherKey: props.key2,
      }}
      >{D[1]}</SomethingElse>
      <ErrorHandler
        onError={(info) => {
          reportError({ [D[8]]: info });
        }}
      />
      <Flex
        style={
          {
            [D[5]]: \`\${topOffset}px\`,
          }
        }
        className={classNames(BLOCK, {
          [\`\${BLOCK}\${D[10]}\`]: isStuck,
        })}
      >{D[0]}</Flex>
      <svg
        fill={props.fill}
        content={(() => { return D[6]; })()}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 192 192"
        data={D[2]}
      >
        <g>
          <rect x='84' y='156' width='20' height='20' />
        </g>
        <path
          d="M102,140H86v-20c0-13.5,10.1-24,22.9-24c13.2,0,23-3,28.9-9c5.9-5.9,6.1-12.9,6.1-13l0-0.4l0-0.4c0-0.4,0.8-11.6-7.6-20.8
C128.8,44.2,115.9,40,98,40c-20.9,0-35.6,5.7-43.7,16.9c-6,8.3-6.3,17-6.3,17.1L32,74c0-1.3,0.2-13.3,8.7-25.5
C54.6,28.2,79.5,24,98,24c22.7,0,39.7,6,50.5,17.9c12.2,13.4,11.7,29.6,11.5,32.5c-0.1,2.5-0.9,14-10.8,23.9
c-9.1,9.1-22.6,13.7-40.3,13.7c-4.6,0-6.9,4-6.9,8V140z"
        />
      </svg>
    </SomeComponent>
  );
}
"
`;

exports[`the ESM version should transform code correctly > for reference-size 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "abcd",
  \`abcdefghi\`,
  "abcde",
  "abc",
  \`abcdefgh\`,
  "xyz0",
  "xyz",
  $\`\`,
  $\`\${0}\${0}\${0}\`,
  "a",
  "ab",
  \`abcde\`,
  \`abcdef\`,
  \`abcdefg\`,
]);
const foo = () => {};

// For short strings, we should use the original string instead of replacing it with a
// dictionary reference.
const short1 = "";
const short2 = "a";
const short3 = "ab";

// Longer strings should be replaced with a dictionary reference.
const long1 = D[3];
const long2 = D[0];
const long3 = D[2];

// Similarly, we should keep short quasis in template literals instead of replacing them
// with a dictionary reference.
const quasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// The dictionary now contains 10 items, which will make the references for any further
// items larger because the size of the index will increase by one character. However,
// we should still be able to use references for all of the examples below, because we
// should be smart enough to reorder the dictionary to make the new items fit.
const twoDigits1 = D[3];
const twoDigits2 = D[0];
const twoDigits3 = D[6];
const twoDigits4 = D[5];

// The same applies to quasis.
const twoDigitsQuasi1 = \`abcde\${5}abcdef\${6}abcdefg\${7}\${D[4]}\${8}\${D[1]}\`;

// We should never replace an empty string, or a sequence of empty quasis, with a
// dictionary reference. (Although for tagged templates, it's a bit trickier to detect
// this case, and so we will continue to generate dictionary entries for them.)
const empty1 = "";
const empty2 = "";
const empty3 = \`\`;
const empty4 = \`\${0}\${1}\${2}\`;
const empty5 = foo(D[7]);
const empty6 = foo(D[8], 0, 1, 2);
"
`;

exports[`the ESM version should transform code correctly > for regular-expressions 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  \`"\`,
]);
import compact from 'lodash/compact';

export const PATTERN = /[:()"\\\\]/g;

const addQuotes = (string, hasQuotes) =>
  hasQuotes ? \`"\${string}"\` : string;
"
`;

exports[`the ESM version should transform code correctly > for string-literals 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "appendix",
  "gem\`'\\"\\u{6F}",
  "cat\\r\\n\\tdog",
  "observe",
  'quarrel',
  'fizz"\\'"',
  "karat",
  'bowling',
  "egg'\\"'",
  "macrame",
  "nanobot",
  "pacific",
  "hammer",
  "image",
  "jewel",
  "labor",
]);
const foo = () => {};

// Trivial string literals.
const trivial1 = "";
const trivial2 = '';
const trivial3 = D[0];
const trivial4 = D[7];

// Escape sequences.
const escape1 = D[2];
const escape2 = D[8];
const escape3 = D[5];
const escape4 = D[1];

// String literals used in expressions.
const expression1 = D[12].toLowerCase();
const expression2 = foo[D[13]];
const expression3 = foo(D[14]);
const expression4 = D[6][1];

// String literals used in function declarations.
const func1 = (_a = D[15]) => {};

// String literals used in object literals.
const object1 = { [D[9]]: 1 };
const object2 = { [D[10]]: 2 };
const object3 = { [D[3]](_a){} };

// String literals used in array literals.
const array1 = [D[11]];
const array2 = [...D[4]];

// Reuse of string literals we've already seen.
const reuse1 = D[0];
const reuse2 = D[6][1];
const reuse3 = { [D[3]](_a){} };
const reuse4 = [...D[4]];
"
`;

exports[`the ESM version should transform code correctly > for switch-statements 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'francis',
  'result',
  'emmett',
  "arnold",
  'betty',
  $\`danielle\`,
  \`charles\`,
]);
const tag = () => D[1];

export const foo = (value) => {
  const emmett = D[2];

  switch (value) {
    case D[3]:
      return 1;

    case D[4]:
      return 2;

    case \`charles\`:
      return 3;

    case tag(D[5]):
      return 4;

    case emmett:
      return 5;

    case D[0]:
      return 6;

    default:
      return 7;
  }
};
"
`;

exports[`the ESM version should transform code correctly > for tagged-templates-only 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  $\`bar\${0}\`,
]);
function foo() { }
console.log(foo(D[0], 1000))
"
`;

exports[`the ESM version should transform code correctly > for templates 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  \`\\\`'"\\u{6F}\`,
  \`abc\\r\\n\\t123\`,
  \`gallingly\`,
  \`hairbrush\`,
  \`idealists\`,
  \`absolute\`,
  \`backdrops\`,
  \`cacophony\`,
  \`dachshund\`,
  \`eagerness\`,
  \`fabricate\`,
  \`newlyweds\`,
  \`orthodoxy\`,
  \`paralyzed\`,
  \`quadrants\`,
  \`reflexive\`,
  \`waferlike\`,
  \`yardstick\`,
  $\`superior\${0}vertical\`,
  $\`triangle\${0}umbrella\`,
  $\`\`,
  $\`judgment\`,
  $\`keyboard\${0}laughter\${0}material\`,
  $\`abstract\`,
  $\`doubtful\${0}endeavor\`,
  $\`bacteria\${0}contrast\`,
]);
const foo = () => {};
const bar = 1;

// Trivial template expressions.
const trivial1 = \`\`;
const trivial2 = \`\${D[5]}\`;
const trivial3 = \`\${D[6]}\${bar}\`;
const trivial4 = \`\${bar}\${D[7]}\`;
const trivial5 = \`\${D[8]}\${bar}\`;
const trivial6 = \`\${D[9]}\${bar}\${D[10]}\`;
const trivial7 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;

// Escape sequences.
const escape1 = \`\${D[1]}\`;
const escape2 = \`\${D[0]}\`;

// Tagged template expressions.
const tagged1 = foo(D[20]);
const tagged2 = foo(D[21]);
const tagged3 = foo(D[22], bar, bar);

// Nested template expressions.
const nested1 = \`\${D[11]}\${\`\${D[12]}\${\`\${D[13]}\`}\${D[14]}\`}\${D[15]}\`;
const nested2 = foo(D[18], foo(D[19], bar));
const nested3 = \`\${D[16]}\${bar}\${D[17]}\${foo(D[23])}\`;

// Using the results of template expressions as a tag.
const resulttag1 = foo(D[25], bar)(D[24], bar);

// Reuse of quasis and template expressions that we've already seen.
const reuse1 = \`\${D[5]}\`;
const reuse2 = \`\${D[2]}\${bar}\${D[3]}\${bar}\${D[4]}\${bar}\`;
const reuse3 = \`\${D[0]}\`;
const reuse4 = foo(D[18], foo(D[19], bar));
"
`;

exports[`the ESM version should transform code correctly > for ternary-expressions 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'katherine',
  "charles",
  'ophelia',
  'richard',
  'result',
  "arnold",
  'george',
  'marcia',
  'nathan',
  "betty",
  'harry',
  'irina',
  'peter',
  'quinn',
  'jack',
  $\`danielle\`,
  $\`emmett\`,
  $\`francine\`,
]);
const tag = () => D[4];

export const arnold = D[5] ? D[9] : D[1];
export const danielle = tag(D[15]) ? tag(D[16]) : tag(D[17]);
export const george = D[6] ? (D[10], D[11]) : (D[14], D[0]);
export const leopold = { [D[7]]: D[8] } ? { [D[2]]: D[12] } : { 'quinn': D[3] };
"
`;

exports[`the ESM version should transform code correctly > for trivial 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  "test",
]);
console.log(/* (attached comment) */ D[0]);

"
`;

exports[`the ESM version should transform code correctly > for typescript-enums 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'Number Three',
  'Number One',
  'Letter A',
  "Letter B",
  "Number Two",
  'Number Two',
  'Letter C',
  'Alpha',
  "Beta",
  \`Letter C\`,
  \`Gamma\`,
]);
enum GreekLetters {
  Alpha = 'Alpha',
  Beta = "Beta",
  Gamma = \`Gamma\`,
}

enum RomanLetters {
  'Letter A' = 'Letter A',
  "Letter B" = "Letter B",
  'Letter C' = \`Letter C\`,
}

const enum ArabicNumbers {
  'Number One' = 'Number One',
  "Number Two" = 'Number Two',
  'Number Three' = 'Number Three',
}
"
`;

exports[`the ESM version should transform code correctly > for typescript-inheritance 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'SpecificNode',
  'pattern',
]);
import { Variant } from './variant';

export class SpecificNode
    extends Variant(D[0])<[string, {}]>
{
    pattern(): string {
        return { escaped: D[1] };
    }
}
"
`;

exports[`the ESM version should transform code correctly > for typescript-namespaces 1`] = `
"import { $ } from ' datadog:privacy-helpers.mjs';
const D = $([
  'betelgeuse',
  'cassiopeia',
  'andromeda',
]);
declare module SomeModule {
  const variable = D[2];
}

declare module "SomeModule" {
  const variable = D[0];
}

declare namespace SomeNamespace {
  const variable = D[1];
}
"
`;

exports[`the ESM version should transform code correctly > for unwanted 1`] = `
"// No strings in this file should appear in the dictionary.
"use strict";
"use server";
"use client";
import "unwanted1.js";
import foo from "unwanted2.js";
import { foo } from "unwanted3.js";
import * as foo from "unwanted4.js";
import { foo as bar1 } from "unwanted5.js";
import { default as bar2 } from "unwanted6.js";
import { "unwanted7" as bar3 } from "unwanted8.js";
export { bar1 };
export { bar1 as bar2 };
export { bar1 as "unwanted9" };
export * from "unwanted10.js";
export * as foo from "unwanted11.js";
export { bar } from "unwanted12.js";
export { default } from "unwanted13.js";
export { default as bar } from "unwanted14.js";
export { foo as "unwanted15" } from "unwanted16.js";
const bar4 = require("unwanted17.js");
const bar5 = import("unwanted18.js");
function doSomething() {
  "use strict";
  return 0;
}
"
`;

exports[`the ESM version should transform code correctly > for unwanted-typescript 1`] = `
"// No strings in this file should appear in the dictionary.
let foo: 'unwanted_var_type_1' | "unwanted_var_type_2";

function bar(
  x: "unwanted_arg_type_1",
  y: 'unwanted_arg_type_2'
): 'unwanted_return_value_type_3' | undefined {
  return undefined;
}

type ObjectType = {
  'unwanted_object_key_type_1': 'unwanted_object_value_type_1'
};

interface InterfaceType {
  'unwanted_interface_key_type_1': 'unwanted_interface_value_type_1'
};

declare let baz: 'unwanted_declared_var_type_1';
"
`;
